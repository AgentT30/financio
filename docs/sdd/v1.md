System Design Document (SDD) â€” V1

Project: Personal Finance Management System
Stack: Django (Python), PostgreSQL, TailwindCSS, Vanilla JS (AJAX)
Hosting: Self-hosted (Docker Compose)
Theme: Dark (default)
Date: November 2025

Table of contents

Goals & constraints

High-level architecture

Components & responsibilities

Conceptual ERD

Data model notes & key tables (conceptual)

Ledger design (double-entry minimal)

Transaction workflows (sequence descriptions)

Investments & funding strategy

Balance & aggregation (materialized balance table)

Django app/module layout & API surface

Database design considerations & indexes

Security & privacy design

Scaling, backups & deployment (Docker)

Observability & logging

Migration strategy & data model evolvability

Acceptance criteria & next steps

1. Goals & constraints

Primary goals

Support user-managed personal finances for India (INR/IST).

Simple UI that stores transactional logs (manual entry) and tracks investments, FDs, loans.

Accurate bookkeeping using a minimal double-entry ledger under the hood while preserving a simple transaction UI.

Fast balance queries via a materialized balance store.

Local, self-hosted Docker deployment.

Constraints

No imports/exports in V1. No external price/AMFI fetchers in V1.

No charts in V1.

2â€“3 users and a few thousand transactions in year one.

Keep schema ready for future features (imports, ML, budgets, capital gains).

2. High-level architecture (textual)
[Browser] <--HTTPS--> [Reverse Proxy (optional)] <---> [Django Web App (Gunicorn + Django)]
                                                   |
                                                   +--> [Postgres DB]
                                                   |
                                                   +--> [Static / Media Volume]


Single web container running Django (Gunicorn + static files served via proxy or Django runserver in local dev).

Single Postgres container for DB.

No Redis/Celery in V1 (kept out for now per decision).

All stateful data is in Postgres; backups via pg_dump/docker volumes externally.

3. Components & responsibilities
3.1 Web (Django)

Render pages & serve API endpoints used by AJAX.

Core business logic: transactions, transfers, investments, FDs, loans, categories.

Ledger layer (Journal & Postings).

Balance materializer (update logic on transaction commit).

3.2 Database (Postgres)

Persistent storage: normalized relational schema.

Maintains:

Users, Accounts, Transactions (UI), JournalEntries, Postings, Categories.

Investments: Instruments, Trades, Holdings.

FDs, Loans.

Materialized balance table(s).

Activity log (CRUD-only).

3.3 Reverse proxy (optional)

Local dev: optional. In production/local with domain: can be Caddy or Nginx.

4. Conceptual ERD (high-level entities & relationships)

This ERD is conceptual (B as requested). It omits columns; instead shows relations and cardinality.

User
 â”œâ”€< SavingsAccount
 â”‚    â””â”€ SavingsAccountBalance (1:1)
 â”œâ”€< CreditCard
 â”‚    â””â”€ CreditCardBalance (1:1)
 â”œâ”€< DigitalWallet
 â”‚    â””â”€ DigitalWalletBalance (1:1)
 â”œâ”€< CashAccount
 â”‚    â””â”€ CashAccountBalance (1:1)
 â”œâ”€< FixedDeposit
 â”‚    â””â”€ FixedDepositBalance (1:1)
 â”œâ”€< LoanAccount
 â”‚    â””â”€ LoanAccountBalance (1:1)
 â”œâ”€< Transaction (UI log, GenericFK to any account)
 â”œâ”€< Transfer (links two transactions/journal entries)
 â”œâ”€< Category
 â”œâ”€< JournalEntry
 â”‚    â””â”€< Posting (many)   -- postings use GenericFK to any account type
 â”œâ”€< Instrument
 â”‚    â””â”€< Trade (many, GenericFK to funding account)
 â”‚         â””â”€ creates/affects Holding
 â””â”€< ActivityLog


Key relationships:

User 1:N SavingsAccount, CreditCard, DigitalWallet, CashAccount, FixedDeposit, LoanAccount

Each Account Type 1:1 Balance (type-specific balance table)

Each Account Type 1:N Transaction (via GenericForeignKey)

Transaction 0/1 â†’ JournalEntry (linked)

JournalEntry 1:N Posting (posting references any Account via GenericFK)

User 1:N Instrument/Trade/Holding

Trade optionally references a FundingAccount (any Account type via GenericFK)

**Architecture Note:** All account types (SavingsAccount, CreditCard, etc.) inherit common fields from an abstract BaseAccount model but are stored in separate tables for better schema clarity and type-specific fields. Relationships to accounts use Django's GenericForeignKey (ContentType framework) for polymorphism.


5. Data model notes & key tables (conceptual)

Below are the core tables and primary purposeâ€”fields described conceptually (not exhaustive columns).

**Core Tables:**

- **users** â€” user profiles, creds (hashed password), preferences (theme), session details.

**Account Tables (Specialized by Type):**

- **savings_accounts** â€” Savings/checking accounts. Fields: user_id, name, subtype (savings/checking/salary), institution, branch_name, ifsc_code, account_number (encrypted), account_number_last4, customer_id, opening_balance, currency, opened_on, status, notes, color, picture, created_at, updated_at.

- **credit_cards** â€” Credit card accounts. Fields: user_id, name, institution, card_number (encrypted), card_number_last4, card_type (visa/mastercard/rupay/amex), credit_limit, billing_day, due_day, expiry_date, opening_balance, currency, status, notes, color, created_at, updated_at.

- **digital_wallets** â€” Digital wallet accounts (UPI apps, mobile wallets). Fields: user_id, name, wallet_type (upi/wallet/other), provider, linked_mobile, upi_id, opening_balance, currency, opened_on, status, notes, color, created_at, updated_at.

- **cash_accounts** â€” Physical cash holdings. Fields: user_id, name, cash_type (wallet/home/other), location, opening_balance, currency, status, notes, color, created_at, updated_at.

- **fixed_deposits** â€” FD accounts. Fields: user_id, name, institution, fd_number, principal_amount, interest_rate, tenure_months, maturity_date, maturity_amount, auto_renewal, opening_balance, currency, opened_on, status, notes, color, created_at, updated_at.

- **loan_accounts** â€” Loan accounts. Fields: user_id, name, loan_type (personal/home/auto/education/other), lender_name, loan_account_number, principal_amount, interest_rate, emi_amount, tenure_months, emi_day, start_date, opening_balance, currency, status, notes, color, created_at, updated_at.

**Balance Tables (One per Account Type):**

- **savings_account_balances** â€” Materialized balances for savings accounts. Fields: account_id (PK, FK to savings_accounts), balance_amount, last_posting_id, updated_at.

- **credit_card_balances** â€” Materialized balances for credit cards. Fields: account_id (PK, FK to credit_cards), balance_amount, last_posting_id, updated_at.

- **digital_wallet_balances** â€” Materialized balances for wallets. Fields: account_id (PK, FK to digital_wallets), balance_amount, last_posting_id, updated_at.

- **cash_account_balances** â€” Materialized balances for cash. Fields: account_id (PK, FK to cash_accounts), balance_amount, last_posting_id, updated_at.

- **fixed_deposit_balances** â€” Materialized balances for FDs. Fields: account_id (PK, FK to fixed_deposits), balance_amount, last_posting_id, updated_at.

- **loan_account_balances** â€” Materialized balances for loans. Fields: account_id (PK, FK to loan_accounts), balance_amount, last_posting_id, updated_at.

**Transaction & Ledger Tables:**

- **categories** â€” hierarchical categories (parent_id), type (expense/income/transfer/fee), color.

- **transactions** â€” user-visible transaction log. Fields: datetime_ist, sign (credit/debit), amount, account_content_type (ContentType), account_object_id (generic FK to any account type), method_type, purpose (free-text), category_id, created_at, updated_at, deleted_at, journal_entry_id (nullable).

- **transfers** â€” (optional table) links two transaction ids OR links two postings, representing a user-visible transfer.

- **journal_entries** â€” journal entries representing the accounting event (zero-sum per currency). Fields: user_id, occurred_at, memo, created_at.

- **postings** â€” postings of each journal entry. Uses GenericForeignKey to reference any account type. Fields: journal_entry_id, account_content_type, account_object_id, amount (signed), currency (INR), posting_type (debit/credit), memo.

**Investment Tables:**

- **instruments** â€” investments: name, symbol, ISIN, type (stock/mf), notes.

- **trades** â€” trade records: user_id, instrument_id, trade_type (buy/sell/dividend/fees), units, price, fees, funding_account_content_type, funding_account_object_id (generic FK to account), date_time, note.

- **holdings** â€” derived aggregation per instrument (units, avg_cost); can be maintained as cached/denormalized table.

**Audit:**

- **activity_logs** â€” CRUD actions: user_id, object_type, object_id, action, diff_json, ip, created_at.

**Architecture Notes:**

1. **Account Polymorphism:** Instead of a single `accounts` table with `type` enum, we use specialized tables per account type (bank_accounts, credit_cards, wallets, cash, etc.) for better schema clarity and type-specific fields.

2. **Generic Foreign Keys:** Postings, Transactions, and Transfers use Django's ContentType framework to reference any account model polymorphically. This allows the ledger to work with all account types while maintaining referential integrity.
   - Transaction.account uses GenericForeignKey (account_content_type + account_object_id)
   - Transfer.from_account uses GenericForeignKey (from_account_content_type + from_account_object_id)
   - Transfer.to_account uses GenericForeignKey (to_account_content_type + to_account_object_id)
   - Posting.account uses GenericForeignKey (account_content_type + account_object_id)

3. **Balance Materialization:** Each account type has its own balance table (one-to-one relationship) for fast balance lookups without complex joins.
   - bank_account_balances â†’ BankAccount
   - credit_card_balances â†’ CreditCard
   - Each stores: balance_amount, last_posting_id, updated_at

4. **Shared Fields:** All account models inherit from an abstract `BaseAccount` model containing common fields (user, name, opening_balance, currency, status, notes, color, picture, timestamps).

5. **Account Selection UI:** Transaction and Transfer forms use a unified dropdown showing all account types with emoji indicators:
   - ðŸ¦ Bank Accounts (Savings, Checking, Current, Salary)
   - ðŸ’³ Credit Cards (Visa, Mastercard, RuPay, Amex)
   - ðŸ“± Digital Wallets (future - UPI apps, mobile wallets)
   - ðŸ’µ Cash Accounts (future - physical cash)
   - Format: "[Emoji] Account Name (Institution/Type)"

6. **Credit Card Debt Tracking:**
   - Credit card balances are typically negative (representing debt/liability)
   - Available Credit = Credit Limit + Current Balance
     - Example: Limit â‚¹50,000, Balance -â‚¹5,000 â†’ Available â‚¹45,000
   - Amount Owed = abs(min(balance, 0))
   - Bill payments (Bank â†’ Credit Card) reduce debt (balance becomes less negative)
   - Expenses on credit cards increase debt (balance becomes more negative)

7. **Dashboard Net Worth Calculation:**
   - Net Worth = Sum of bank account balances + Investment values
   - Does NOT subtract credit card debt (per user requirement)
   - Credit card debt is tracked separately via available credit and amount owed metrics



6. Ledger design â€” minimal double-entry

Design choice: Minimal double-entry per your choice (A). Each accounting event should be represented by a journal_entry with at least two postings that net to zero (in base currency INR).

Properties

journal_entries has id, user_id, occurred_at (IST), memo.

postings has journal_entry_id, account_id, amount (DECIMAL; positive = debit? We'll pick a consistent sign convention), side optional (debit/credit), and currency (INR).

Enforce SUM(postings.amount) == 0 at application level when creating entries; constraint in DB via trigger/check can be added later.

Sign convention (implementation recommendation)

Use a canonical numeric sign: postings store signed amounts in INR, with positive meaning increase asset/equity depending on account type is complexâ€”so prefer storing amount as signed and keep direction field per posting:

Simpler: amount is positive; is_debit boolean indicates debit/credit; application maps amount to account balances.

For V1, keep posting.amount as signed numeric: debits positive, credits negative. Sum must be zero.

Mapping UI Transaction to Journal

A user transaction (Expense Debit) creates:

JournalEntry (memo = purpose/user note)

Posting 1: Debit: Category ledger (or Expense ledger) â€” we represent categories as analytic tags, not ledger accounts; to keep minimal double-entry, we will:

Posting A (Debit): Expense placeholder posting (synthetic ledger account per category or a generic expense control account) â€” Required so that postings sum to zero.

Posting B (Credit): The user's account (bank/credit card) with negative amount.

For transfer: create journal entry with two postings:

Debit: Destination account +X

Credit: Source account âˆ’X

Why minimal approach?

Keeps UI simple and avoids full chart-of-accounts complexity while preserving correctness for transfers & investments.

Allows future migration to full accounting if necessary.

7. Transaction & Transfer workflows (sequences)

All sequences assume IST timestamping; transactions are user-scoped.

7.1 Create Transaction (Expense/Credit)

User submits the New Transaction form (date, C/D, amount, account, type, purpose, category).

Backend validates fields.

Begin DB transaction.

Create transactions row (UI record).

Create journal_entry row referencing transactions.id and memo.

Create postings:

Posting 1: Expense/Income ledger posting (synthetic control account) â€” amount = +X for debit or âˆ’X for credit, depending on sign convention.

Posting 2: Account posting for account_id with opposite amount (so sum=0).

Update balances_materialized for involved account_id(s) (atomic update).

Record activity_logs entry.

Commit DB transaction.

Return success to UI; UI refreshes relevant lists.

7.2 Create Transfer

User opens Transfer modal and submits (from_account, to_account, amount, method, purpose).

Validate that from != to and amount > 0.

Begin DB transaction.

Create transactions entries for both sides (optionally create one transfer record linking them).

Create a single journal_entry with two postings:

Debit: To Account (amount)

Credit: From Account (âˆ’amount)

Update balances_materialized for both accounts (atomic).

Activity log entry.

Commit.

UI shows single transfer row with link to both transactions/postings.

7.3 Create Trade (Buy / Sell)

User submits trade with instrument, units, price, fees, funding_account_id.

Validate trade data.

Begin DB transaction.

Create trade record.

Create journal_entry:

For Buy:

Debit: Investment holding (synthetic asset ledger) â€” cost basis

Credit: Funding Account (bank) â€” amount paid (units*price + fees)

Also create posting for fees to Fee ledger if fees exist.

For Sell:

Debit: Funding Account (bank) â€” proceeds

Credit: Investment holding â€” cost basis (realized portion)

Additional postings for realized P/L to P/L ledger (in future; in V1, you can track realized by lot calculation without P/L ledger)

Update holdings (lot allocation, FIFO).

Update balances_materialized if funding account impacted.

Activity log.

Commit.

Note: In V1 we keep realized P&L simple; holdings are tracked with lots, FIFO used for sell matching.

8. Investments & funding strategy

You indicated you'll add funds to your investment account and then use it to buy/sell. Implementation detail:

Investments module is separate (instruments, trades, holdings).

Funding strategy: Trades optionally accept a funding_account_id. For your workflow, you will:

Create or use an existing Account (Savings/Wallet) dedicated as an "Investment Funding" account.

When you deposit money into that funding account (via a Transaction or Transfer), the account balance increases.

When creating a Buy trade, you select that funding account; ledger postings reduce the funding account and increase the investment holdings.

This approach gives you the semantics you requested while honoring the decision that investments are tracked as a separate module.

Trade lifecycle notes

Trades require instrument existence (create instrument inline if missing).

Units can be decimals (MF units) or integers (stocks).

Fees are recorded as additional postings to a Fees/Expense control ledger.

Lot tracking

Maintain lots table to support FIFO matching:

On Buy: create lot with quantity/remaining quantity and cost per unit.

On Sell: consume lots in FIFO order; compute realized quantity and realized cost for reporting (cap gains later).

For V1 we store lot-level data so future capital gains calculations are possible.

9. Balance & aggregation (materialized balance table)

Strategy chosen: Materialized balance table (C).

Table: account_balances (denormalized store)

Fields: account_id, balance_amount, last_posting_id, updated_at

Purpose: Fast reads for account list, dashboard, net-worth calc.

Update strategy

On every successful journal entry creation (commit), update account_balances for affected accounts atomically.

Use DB transaction + SELECT ... FOR UPDATE or UPDATE ... SET balance_amount = balance_amount + :delta to avoid race conditions.

For restoration, re-compute balances by replaying postings from a checkpoint if needed (maintenance tool).

Net worth

Net worth is sum of account_balances.balance_amount for asset accounts + holdings value (cost or manual price if available).

Materialized views (future)

In V2, we will add materialized views for aggregates: spend_by_category_monthly, net_worth_timeline, etc. For V1, simple queries + balances table suffice.

10. Django app & module layout (recommended â€” modular B)

Recommended Django apps and responsibilities:

core/            # shared utilities, middleware, common templates
accounts/        # Account model, account views, account forms
authn/           # Sign up/login/logout, password change
transactions/    # transactions UI model (transactions), view logic, filters
ledger/          # JournalEntry, Postings, ledger helpers, posting creation API
transfers/       # Transfer forms & views (could be inside transactions)
categories/      # category management and default seed
investments/     # Instrument, Trade, Holding, Lot, Price
fds/             # FD records & views
loans/           # Loan records & views
reports/         # report endpoints & queries (server-side)
activity/        # activity_log model & views
ui/              # common page components, templates


APIs / Views

Use Django class-based views + endpoint style URLs for table AJAX.

Example endpoints:

GET /transactions/ â€” transactions page (paginated)

POST /transactions/new/ â€” create transaction (form)

POST /transfers/new/ â€” create transfer (form)

GET /accounts/ â€” account list

POST /accounts/new/

GET /investments/holdings/, POST /investments/trade/ etc.

Forms & validation

Use Django forms for server-side validation; Ajax for asynchronous saves.

Enforce ledger constraints at the service layer (transactional atomic operations).

11. Database design considerations & indexes

Datatypes

Money: use numeric(18,2) for INR amounts.

Datetimes: store in timestamp with time zone with application always writing IST; recommended to store naive or timezone-aware consistentlyâ€”per your choice you requested IST stored; so store timestamp without time zone but document that server timezone must be IST. (Alternative recommended: store UTC and translate to IST on displayâ€”however you insisted store in IST for easier querying; we will store IST timestamp and ensure DB timezone is configured accordingly.)

Indexes (recommended)

transactions(user_id, account_id, date) â€” composite index for filtering lists.

transactions(user_id, date, amount) â€” for searches.

postings(journal_entry_id), postings(account_id) â€” for balance replays.

account_balances(account_id) â€” primary key.

trades(user_id, instrument_id, date)

holdings(user_id, instrument_id) with unique constraint.

activity_logs(user_id, created_at) for activity queries.

Constraints & integrity

Foreign keys for all references.

Use DB transactions for creation of transaction + journal_entry + postings + account_balances updates.

Application-level assertion that SUM(postings.amount) == 0 when a journal entry is created.

Partitioning

Not necessary for initial scale. If scaling to many transactions, partition transactions and postings by range (year) or by user_id.

12. Security & privacy design

Authentication

Passwords hashed with Argon2 or bcrypt (Django supports Argon2 via django[argon2]).

Email + password signup & login.

Session

Session timeout = 2 weeks.

Session cookie secure and HttpOnly.

Authorization

Row-level scoping in all queries: always filter by user_id in ORM queries.

Never expose other usersâ€™ data.

Data masking

Mask account numbers in UI (last 4 visible).

Option to reveal for 10s via toggle (auditable).

Sensitive data

Do not store full PAN, CVV, or full card numbers. Only masked identifiers.

No card tokens or bank credentials stored in V1.

Transport

HTTPS recommended for deployment; for local dev, HTTP is acceptable.

Audit

Activity log CRUD-only for V1 (creation/edit/delete), capturing user, timestamp (IST), ip, and diff JSON.

13. Scaling, backups & deployment (Docker)

Docker Compose (V1)

web: Django app (Gunicorn) â€” serves dynamic pages and AJAX endpoints.

db: PostgreSQL 16 â€” persists data in volume /var/lib/postgresql/data.

(Optional) proxy: Nginx or Caddy if wanting TLS/reverse-proxy locally.

Volumes

db_data volume for Postgres.

Backups

Use pg_dump to export backups; include a simple Makefile or bash script in repo to run:

docker exec -t <db> pg_dump -U <user> <db> > backup.sql

Scaling notes

For the requested small scale (2â€“3 users, thousands of transactions), single Postgres + single web container is sufficient.

Future: add Redis, Celery, worker containers for ingestion & heavy analytics; add caching/proxy; shard/partition DB; move files to object store.

14. Observability & logging

Logging

Server logs: Django log to stdout for easy capture by Docker.

Error logs: store traceback on server console; return generic error messages to UI.

Metrics

Minimal in V1: basic request counts, error counts. Use simple Prometheus exporter later.

Activity

Activity logs stored in DB for UI view.

15. Migration strategy & evolvability

Principles

Keep migrations small and reversible.

Keep UI models (transactions) separate from ledger models to allow future schema refactoring.

Seed initial category tree via migration.

Add columns with defaults/nullable rather than destructive changes where feasible.

Upgrades

To add imports later, create imports table and import_batch FK on transactions.

To add prices/API feeds, create prices table for instruments and scheduled worker job to fetch.

16. Acceptance criteria (short checklist)

 User sign up/login/logout works; session persists 2 weeks.

 User can create/edit/soft-delete accounts (savings, credit, wallet, cash, FD, loan).

 User can add transactions (Credit/Debit) with fields: Date(IST), C/D, Amount, Account, Type, Purpose, Category.

 Transfers create balanced postings and update both accountsâ€™ balances.

 Journal entries and postings created for every transaction; postings sum to zero.

 Investments: user can create Instruments; create Trades (Buy/Sell/Dividend/Fees) and holdings updated (lot tracking FIFO).

 FD & Loan metadata can be created & viewed.

 Dashboard shows net-worth (sum of account_balances + holdings cost).

 Activity log records CRUD actions for accounts/transactions/instruments.

 Materialized account balances update on transaction/trade commit and feed dashboard quickly.

 UI is responsive and uses dark mode by default; theme toggle stored in user settings.

Appendix: Key design decisions & rationale (concise)

Minimal double-entry gives correctness for transfers & investments with minimal accounting complexity. Keeps UI simple but ledger correct.

Hybrid model (user-visible transactions + ledger entries) simplifies UI operations, import later, and provides provenance.

Investments as separate module: keeps securities management and lot tracking separate from generic accounts, enabling future capital gains features.

Materialized balance table: supports fast dashboard reads and net-worth calculations without expensive full scans.

No Celery/Redis in V1: keeps deployment simpler; added later for background enrichment/analytics.

Store datetimes in IST per your request for easier queryingâ€”ensure server timezone alignment.